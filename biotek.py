import pandas as pd
import functools
from utils import set_manufacturer_for_organization, combine_dataframes

@functools.lru_cache(maxsize=128)
def get_prices(organization):
    """Повертає ціни в залежності від вибраного представника."""
    # Словник з цінами для кожної організації.
    # Кожна організація має свій словник, де ключ – назва товару, а значення – його ціна.
    prices_dict = {
        'Arterium': {
            "Тиоцетам 10мл №10": 94077,
            "Тиоцетам 5мл №10": 70275,
            "Тиоцетам 400мг/100мг №30 табл.": 52007,
            "Элкоцин 100мг №30 табл.": 76028,
            "Ларитилен №20 табл. мяты": 24430,
            "Ларитилен №20 табл. мяты и малины": 24430,
            "Ларитилен №20 табл.мяты и лимон": 24430,
            #------------------------------------------
            'Ларитилен №20 (со вкусом мяты)': 24430,
            'Ларитилен №20 (со вкусом мяты и лимона)': 24430,
            'Ларитилен №20 (со вкусом мяты и малины)': 24430,
            'Тиоцетам 5мл №10': 70275,
            'Тиоцетам 10мл №10': 94077,
            'Тиоцетам таб. 400мг/100мг №30': 52007,
            'Элкоцин 100мг №30': 76028,
            'Формен комби, капс №40': 94280,
            #-------------------------------------------
            "Резистол 50мл": 84290,
            "Резистол капли 20мл": 49000,
            "Тиотриазолин форте 50мг-4мл №10": 173532
        },
        'Stada': {
            "Тиоцетам 10мл №10": 1,
            "Тиоцетам 5мл №10": 1,
            "Тиоцетам 400мг/100мг №30 табл.": 1,
            "Уролесан 180мл": 1,
            "Уролесан 25мл": 1,
            "Элкоцин 100мг №30 табл.": 1,
            "Ларитилен №20 табл. мяты": 1,
            "Ларитилен №20 табл. мяты и малины": 1,
            "Ларитилен №20 табл.мяты и лимон": 1
        },
        'Binnopharm Group':{
            'Венарус 1000 табл. п/о 1000 мг №30 Алиум Россия': 202542,
            'Венарус 1000 табл. п/о 1000 мг №60 Алиум Россия': 301722,
            'Венарус 500 табл. п/о 500 мг №30 Алиум Россия': 106030,
            'Венарус 500 табл. п/о 500 мг №60 Алиум Россия': 184129,
            'Дексонал табл. 25 мг №10 Алиум Россия': 50702,
            'Кагоцел табл. 12 мг №10 Ниармедик Фарма Россия': 49656,
            'Кагоцел табл. 12 мг №20 Ниармедик Фарма Россия': 98908,
            'Необутин Ретард табл. п/о 300 мг №20 Алиум Россия': 92154,
            'Необутин Ретард табл. п/о 300 мг №60 Алиум Россия': 243548,
            'Необутин табл. 100 мг №10 Алиум Россия': 50702,
            'Необутин табл. 200 мг №30 Алиум Россия': 94288,
            #--------------------------------------------------------
            'Кагоцел таб. 0,012 №10': 49656,
            'Кагоцел таб.12мг №20': 98908,
            'Венарус 1000мг №30': 202542,
            'Венарус 1000мг №60': 301722,
            'Венарус 500мг №30': 106030,
            'Венарус 500мг №60': 184129,
            'Дексонал 25мг №10': 50702,
            'Кагоцел таб. 0,012 №10': 49656,
            'Кагоцел таб.12мг №20': 98908,
            'Необутин 100мг №10': 50702,
            'Необутин 200мг №30': 94288,
            'Необутин Ретард 300мг №20': 92154,
            'Необутин Ретард 300мг №60': 243548
        },
        'Без организации': {}
    }
    # Повертаємо словник цін для заданої організації або порожній словник, якщо організація відсутня
    return prices_dict.get(organization, {})

def process_biotek_excel(file_path, organization):
    """Обробляє завантажений Excel файл і повертає оброблений DataFrame."""
    
    # =========================
    # Читання файлу та встановлення заголовків
    # =========================
    # Зчитуємо Excel файл, пропускаючи перші 7 рядків (ймовірно, заголовки чи непотрібну інформацію),
    # і не використовуємо перший рядок як заголовок (header=None)
    df = pd.read_excel(file_path, skiprows=7, header=None)
    
    # Встановлюємо власні назви колонок для DataFrame
    df.columns = ['№', 'Номенклатура', 'Клиент', 'Счет-фактура', 'Дата', 'Цена', 'Количество', 'Сумма', 'Город', 'Адрес', 'ИНН']
    
    # Видаляємо колонку '№', оскільки вона не потрібна для подальшої обробки
    df = df.drop(columns=['№'])
    
    # =========================
    # Фільтрація даних
    # =========================
    # Видаляємо рядки, де відсутні значення в ключових стовпцях 'Номенклатура' та 'ИНН'
    df = df.dropna(subset=['Номенклатура', 'ИНН'])
    
    # Видаляємо перший рядок DataFrame, який може містити непотрібну інформацію або дубльовані заголовки
    df = df.drop(index=0)
    
    # =========================
    # Обробка дати
    # =========================
    # Конвертуємо стовпець 'Дата' у формат datetime з форматом "день.місяць.рік".
    # Якщо формат не відповідає очікуваному, значення стають NaT (Not a Time)
    df['Дата'] = pd.to_datetime(df['Дата'], format='%d.%m.%Y', dayfirst=True, errors='coerce')

    # =========================
    # Обробка кількості
    # =========================
    # Перетворюємо стовпець 'Количество' у числовий тип, обробляючи можливі помилки
    df['Количество'] = pd.to_numeric(df['Количество'], errors='coerce')
    
    # Округлюємо значення у стовпці 'Количество'
    df['Количество'] = df['Количество'].round()

    # =========================
    # Отримання цін для вибраної організації
    # =========================
    # Викликаємо функцію get_prices для отримання словника з цінами для заданої організації
    prices = get_prices(organization)
    df['Цена'] = df['Номенклатура'].map(prices).fillna(1)
    df['Цена'] = pd.to_numeric(df['Цена'], errors='coerce')
    # =========================
    # Оновлення інформації про виробника
    # =========================
    # Викликаємо зовнішню функцію set_manufacturer_for_organization для встановлення або оновлення інформації про виробника
    df = set_manufacturer_for_organization(df, organization) 
    
    # =========================
    # Розрахунок суми та встановлення ціни
    # =========================
    if organization == 'Stada':
        # Якщо організація 'Stada', встановлюємо суму продажу рівною 1 (можливо, логіка для цієї організації відрізняється)
        df['Сумма'] = 1
    elif organization == 'Arterium':
        # Для організації 'Arterium':
        # Якщо 'Номенклатура' товару є в словнику цін, розраховуємо суму як добуток 'Количество' на 'Цена'
        # Якщо товару немає в словнику, встановлюємо суму рівною 1
        df['Сумма'] = df.apply(
            lambda row: row['Количество'] * row['Цена'] if row['Номенклатура'] in prices else 1,
            axis=1
        )
    elif organization == 'Binnopharm Group':
        # Для організації 'Binnopharm Group':
        # Аналогічно, якщо 'Номенклатура' присутня у словнику цін, розраховуємо суму як добуток 'Количество' на 'Цена',
        # інакше – встановлюємо суму рівною 1
        df['Сумма'] = df.apply(
            lambda row: row['Количество'] * row['Цена'] if row['Номенклатура'] in prices else 1,
            axis=1
        )    
    else:
        # Для інших організацій розраховуємо суму як добуток 'Количество' на 'Цена'
        df['Сумма'] = df['Количество'].astype(float) * df['Цена'] 

    # =========================
    # Перевірка стовпця "Производитель"
    # =========================
    # Якщо стовпець 'Производитель' відсутній, встановлюємо його значення за замовчуванням як "Без организации"
    if 'Производитель' not in df.columns:
        df['Производитель'] = 'Без организации'
    
    # =========================
    # Перевпорядкування колонок
    # =========================
    # Додаємо стовпець "Номер" з послідовними номерами для кожного рядка
    df['Номер'] = range(1, len(df) + 1)
    
    # Переставляємо колонки так, що "Номер" буде першою колонкою, а інші йтимуть після нього
    columns = ['Номер'] + [col for col in df.columns if col != 'Номер']
    df = df[columns]  
    
    # =========================
    # Об'єднання даних
    # =========================
    # Об'єднуємо DataFrame за допомогою зовнішньої функції combine_dataframes.
    # У даному випадку об'єднується лише один DataFrame, але функція може підтримувати об'єднання декількох.
    combined_df = combine_dataframes([df])

    # Повертаємо оброблений DataFrame
    return df
