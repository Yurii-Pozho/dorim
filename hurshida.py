import pandas as pd
import functools
from utils import set_manufacturer_for_organization, combine_dataframes

@functools.lru_cache(maxsize=128)
def get_prices(organization):
    """Повертає ціни в залежності від вибраного представника."""
    # Словник з цінами для кожної організації.
    # Ключем є назва організації, а значенням – словник з парами "назва товару: ціна".
    prices_dict = {
        'Arterium': {
            "Ларитилен таб. со вкусом мяты №20 ": 24430,
            "Ларитилен таб. со вкусом мяты и малина №20 ": 24430,
            "Ларитилен таб. со вкусом мяты и лимона №20 ": 24430,
            "Тиоцетам р-р д/ин. 5мл №10": 70275,
            "Тиоцетам таб. 400мг/100мг №30": 52007,
            "Тиоцетам р-р д/ин. 10мл №10": 94077,
            "Элкоцин таб. 100мг №30": 76028,
            "Формен комби капс. №40": 94280,
            "Резистол капли оральные 20мл": 49000,
            "Резистол капли оральные 50мл": 84290,
            "Тиотриазолин форте амп. 50мг/мл 4мл №10": 173532
        },
        'Binnopharm Group': {
            "Венарус таб. 1000мг №30": 301722,
            "Венарус таб. 1000мг №60": 301722,
            "Венарус таб. 500мг №60": 184129,
            "Дексонал таб. 25мг №10": 50702,
            "Кагоцел таб. 12мг №10": 49656,
            "Кагоцел таб. 12мг №20": 98908,
            "Необутин ретард таб. 300мг №20": 92154,
            "Необутин таб. 100мг №10": 50702,
            "Необутин таб. 200мг №30": 94288
        },
        'Stada': {
            "Кагоцел таб. 12мг №10": 49656,
            "Тиоцетам 10мл №10": 1,
            "Тиоцетам 5мл №10": 1,
            "Тиоцетам 400мг/100мг №30 табл.": 1,
            "Уролесан 180мл": 1,
            "Уролесан 25мл": 1,
            "Элкоцин 100мг №30 табл.": 1,
            "Ларитилен №20 табл. мяты": 1,
            "Ларитилен №20 табл. мяты и малины": 1,
            "Ларитилен №20 табл.мяты и лимон": 1
        },
        'Без организации': {}
    }
    # Повертаємо словник цін для вибраної організації,
    # або порожній словник, якщо організація відсутня у визначених.
    return prices_dict.get(organization, {})

def process_hurshida_excel(file_path, organization):
    """Обробляє завантажений Excel файл і повертає оброблений DataFrame."""
    
    # =========================
    # Зчитування файлу
    # =========================
    # Зчитуємо Excel файл без заголовків (header=None),
    # що дозволяє працювати з даними як з сирим набором рядків.
    df = pd.read_excel(file_path, header=None)
    
    # =========================
    # Видалення непотрібних рядків
    # =========================
    # Видаляємо перші два рядки, які можуть містити додаткову інформацію чи заголовки,
    # і скидаємо індекси після видалення.
    df = df.drop(index=[0, 1]).reset_index(drop=True)
    
    # =========================
    # Призначення нових назв колонок
    # =========================
    # Визначаємо список нових назв колонок відповідно до структури даних.
    new_column_names = [
        "№",
        "Код",
        "Номенклатура",
        "Производитель",
        "ИНН",
        "Наименование покупателя",
        "Регион",
        "Адрес организации",
        "№ док.",
        "Дата док.",
        "Количество",
        "Цена отпускная",
        "Сумма отпускная",
        "% нац."
    ]
    # Присвоюємо нові назви колонок DataFrame.
    df.columns = new_column_names
    
    # =========================
    # Перевірка наявності ключових стовпців
    # =========================
    # Перевіряємо, чи присутні в DataFrame стовпці "Номенклатура" та "ИНН".
    if 'Номенклатура' not in df.columns or 'ИНН' not in df.columns:
        raise ValueError("Відсутні необхідні стовпці: 'Номенклатура' або 'ИНН'.")
    
    # =========================
    # Фільтрація рядків
    # =========================
    # Видаляємо рядки, де відсутні значення в стовпцях "Номенклатура" або "ИНН",
    # адже ці дані є ключовими для подальшої обробки.
    df = df.dropna(subset=['Номенклатура', 'ИНН'])
    
    # =========================
    # Обробка дати
    # =========================
    # Обрізаємо зайві пробіли у стовпці "Дата док."
    df['Дата док.'] = df['Дата док.'].str.strip()
    # Розбиваємо значення в стовпці "Дата док." на дві частини: дату та час.
    # При цьому створюємо два нові стовпці: "Дата" та "Час". Нас цікавить лише дата.
    df[['Дата', 'Час']] = df['Дата док.'].str.split(' ', n=1, expand=True)
    
    # Конвертуємо значення в стовпці "Дата" у формат datetime згідно з форматом "день.місяць.рік".
    df['Дата'] = pd.to_datetime(df['Дата'], format='%d.%m.%Y', dayfirst=True, errors='coerce')
    
    # =========================
    # Обробка кількості
    # =========================
    # Перетворюємо значення в стовпці "Количество" у числовий тип із обробкою помилок.
    df['Количество'] = pd.to_numeric(df['Количество'], errors='coerce')
    # Округлюємо значення в стовпці "Количество".
    df['Количество'] = df['Количество'].round()
    # Фільтруємо рядки, де значення "Количество" є валідним (не NaN).
    df = df[df['Количество'].notna()]
    
    # =========================
    # Призначення цін
    # =========================
    # Отримуємо словник з цінами для заданої організації за допомогою функції get_prices.
    prices = get_prices(organization)
    
    # Якщо стовпець "Цена" відсутній, створюємо його з початковим значенням None.
    if 'Цена' not in df.columns:
        df['Цена'] = None
    
    # Якщо словник з цінами не порожній, зіставляємо значення стовпця "Номенклатура" із ціновим словником.
    # Якщо відповідна ціна не знайдена, встановлюємо значення за замовчуванням (1).
    if prices:
        df['Цена'] = df['Номенклатура'].map(prices).fillna(1)
        # Перетворюємо значення стовпця "Цена" у числовий тип для подальших обчислень.
        df['Цена'] = pd.to_numeric(df['Цена'], errors='coerce')
    
    # =========================
    # Розрахунок суми
    # =========================
    # В залежності від організації обчислюємо суму:
    # - Для 'Stada' сума встановлюється рівною 1.
    # - Для 'Arterium' та 'Binnopharm Group' суму обчислюємо як добуток "Количество" на "Цена",
    #   якщо товар (Номенклатура) є в ціновому словнику, інакше – 1.
    # - Для інших організацій сума розраховується як добуток "Количество" на "Цена".
    if organization == 'Stada':
        df['Сумма'] = 1
    elif organization == 'Arterium':
        df['Сумма'] = df.apply(
            lambda row: row['Количество'] * row['Цена'] if row['Номенклатура'] in prices else 1,
            axis=1
        )
    elif organization == 'Binnopharm Group':
        df['Сумма'] = df.apply(
            lambda row: row['Количество'] * row['Цена'] if row['Номенклатура'] in prices else 1,
            axis=1
        )
    else:
        df['Сумма'] = df['Количество'].astype(float) * df['Цена']
    
    # =========================
    # Обробка даних про виробника
    # =========================
    # Якщо стовпець "Производитель" відсутній, встановлюємо значення за замовчуванням "Без организации".
    if 'Производитель' not in df.columns:
        df['Производитель'] = 'Без организации'
    
    # =========================
    # Видалення зайвих стовпців
    # =========================
    # Видаляємо оригінальний стовпець "Дата док.", оскільки інформація вже витягнута в окремий стовпець "Дата".
    df = df.drop(columns=['Дата док.'])
    # Видаляємо стовпець з початковим порядковим номером, якщо він не потрібен (у цьому прикладі "№").
    df = df.drop(columns=['№'])
    
    # =========================
    # Додавання порядкового номера
    # =========================
    # Додаємо новий стовпець "Номер", що містить послідовні номери для кожного рядка.
    df['Номер'] = range(1, len(df) + 1)
    
    # Переставляємо колонки так, щоб "Номер" був першою колонкою, а всі інші – після нього.
    columns = ['Номер'] + [col for col in df.columns if col != 'Номер']
    df = df[columns]
    
    # =========================
    # Оновлення даних про виробника
    # =========================
    # Викликаємо функцію set_manufacturer_for_organization для встановлення або оновлення інформації
    # про виробника залежно від обраної організації.
    df = set_manufacturer_for_organization(df, organization)
    
    # =========================
    # Об'єднання даних
    # =========================
    # Обгортаємо отриманий DataFrame у список та об'єднуємо дані за допомогою функції combine_dataframes.
    df_list = [df]  # При потребі можна об'єднати декілька DataFrame.
    combined_df = combine_dataframes(df_list)
    
    # Повертаємо остаточний оброблений DataFrame.
    return df
