import pandas as pd
import functools
from utils import set_manufacturer_for_organization, combine_dataframes
import json

@functools.lru_cache(maxsize=128)
def get_prices(organization):
    """Повертає ціни в залежності від вибраного представника."""
    # Словник з цінами для кожної організації.
    # Для кожної організації задається словник, де ключ — назва товару, а значення — його ціна.
    prices_dict = {
        'Arterium': {
            "Ларитилен таб. для рассасыв. №20 (со вкусом мяты и лимона)": 24430,
            "Ларитилен таб. для рассасыв. №20 (со вкусом мяты и малины)": 24430,
            "Ларитилен таб. для рассасыв. №20 (со вкусом мяты)": 24430,
            "Тиоцетам амп.10мл№10": 94077,
            "Тиоцетам амп.5мл№10": 70275,
            "Тиоцетам таб. 400мг/100мг №30": 52007,
            "Тиотриазолин Форте р-р д/инъек. 50мг/мл 4мл №10": 173532,
            "Резистол капли оральн. 20мл": 49000,
            "Резистол капли ораль. 50мл": 84290
        },
        'Astra Zeneca': {
            "Беталок ЗОК таб. 100мг №30": 110378,
            "Беталок ЗОК таб. 25мг №14": 41931,
            "Брилинта таб. 90мг.№56": 964270,
            "Золадекс имп. спрол. всвоб. для подкож. введ. 3,6мг №1": 1312851,
            "Нексиум таб. 20мг №14": 85369,
            "Нексиум таб. 40мг №14": 115488,
            "Пульмикорт сусп 0,25мг/2мл№20": 253475,
            "Пульмикорт сусп 0,5мг/2мл№20": 313488,
            "Симбикорт турбухалер пор. 160/4,5мкг/60доз№1": 282270,
            "Симбикорт турбухалер пор.80/4,5мкг/60доз№1": 245313,
            "Форсига таб.10мг №28": 523703
        },
        'Binnopharm Group': {
            "Венарус таб. 1000мг №30": 202542,
            "Венарус таб.500мг №30": 106030,
            "Венарус таб.500мг №60": 184129,
            "Дексонал таб. 25мг №10": 50702,
            "Необутин ретард таб. 300мг №20": 92154,
            "Необутин ретард таб. 300мг №60": 243548,
            "Необутин таб. 100мг №10": 50702,
            "Необутин таб. 200мг №30": 94288
        },
        'Egis': {
            "Алзепил таб. 10мг №28": 377431,
            "Алзепил таб. 5мг №28": 204751,
            "Алотендин таб. 10мг/10мг №30": 107087,
            "Алотендин таб. 5мг/10мг №30": 80928,
            "Алотендин таб. 5мг/5мг №30": 87790,
            "Бетадин ваг.супп. 200мг №14": 85220,
            "Бетадин мазь 20 г": 48168,
            "Бетадин р-р 1000мл": 230981,
            "Бетадин р-р 120мл": 66617,
            "Бетадин р-р 30мл": 37222,
            "Велаксин 37,5мг капс №28": 97462,
            "Велаксин 75мг капс №28": 200879,
            "Грандаксин таб. 50мг. №20": 62375,
            "Кетилепт таб 200мг  №60": 584802,
            "Кетилепт таб 25мг №30": 52432,
            "Клостилбегит таб. №10": 146274,
            "Летирам таб. 1000мг №60": 611255,
            "Летирам таб. 500мг №60": 390523,
            "Летирам таб.250мг №60": 200658,
            "Розулип 10 мг №28": 98696,
            "Розулип 20 мг №28": 163740,
            "Розулип Плюс капс. 10мг/10мг №60": 361357,
            "Розулип Плюс капс. 20мг/10мг №60": 408542,
            "Сорбифер дурулес таб. 320мг.№30": 62357,
            "Сорбифер дурулес таб.320мг №50": 77954,
            "Стимулотон таб. 50мг. №30": 109986,
            "Супрастин 20мг 1мл.№5": 40212,
            "Супрастин таб. 25мг. №20": 29014,
            "Супрастинекс  таб. 5мг №30": 72436,
            "Супрастинекс капли для приема внутрь 5мг/мл 20мл": 70701,
            "Таллитон таб. 12,5мг №28": 78336,
            "Таллитон таб. 25мг №28": 98333,
            "Таллитон таб. 6,25мг №28": 61991,
            "Торвазин плюс капс.10мг+10мг №30": 130236,
            "Торвазин плюс капс.20мг+10мг №30": 162790,
            "Грандаксин таб. 50мг. №60": 167830,
            "Кетилепт таб 100мг №60 ": 298244,
            "Кетилепт таб 100мг  №60": 298244,
            "Кетилепт таб 100мг  №60": 298244
        },
        'Stada': {
            # Для організації Stada ціни можуть встановлюватися окремо (тут значення закоментовано).
            # "Тиоцетам 10мл №10": 1,
            # "Тиоцетам 5мл №10": 1,
            # "Тиоцетам 400мг/100мг №30 табл.": 1,
            # "Уролесан 180мл": 1,
            # "Уролесан 25мл": 1,
            # "Элкоцин 100мг №30 табл.": 1,
            # "Ларитилен №20 табл. мяты": 1,
            # "Ларитилен №20 табл. мяты и малины": 1,
            # "Ларитилен №20 табл.мяты и лимон": 1
        },
        'Без организации': {}
    }
    # Повертаємо словник цін для заданої організації, або порожній словник, якщо організація не визначена.
    return prices_dict.get(organization, {})

def process_meros_excel(file_path, organization):
    """Обробляє завантажений Excel файл і повертає оброблений DataFrame."""
    
    # =========================
    # Зчитування даних з Excel файлу
    # =========================
    # Зчитуємо всі аркуші Excel файлу у словник DataFrame'ів.
    df_all = pd.read_excel(file_path, sheet_name=None)
    
    # =========================
    # Визначення потрібного аркуша
    # =========================
    # Шукаємо аркуш, ім'я якого містить один із заданих патернів:
    # "Продажи", "Продажа", "Конструктор отчетов" або "Sales Meros".
    sheet_name = next(
        (name for name in df_all if any(pattern in name for pattern in ["Продажи", "Продажа", "Конструктор отчетов", "Sales Meros"])),
        None
    )
    if sheet_name is None:
        raise ValueError("Аркуш не знайдено.")
    
    # =========================
    # Зчитування даних з вибраного аркуша
    # =========================
    # Зчитуємо дані з вибраного аркуша без встановлення заголовків.
    sheet_data = pd.read_excel(file_path, sheet_name=sheet_name, header=None)
    
    # =========================
    # Визначення рядка із заголовками
    # =========================
    # Шукаємо рядок, що містить слово "ТМЦ", яке є індикатором наявності заголовків.
    header_row = None
    for i, row in sheet_data.iterrows():
        if "ТМЦ" in row.values:
            header_row = i
            break
    
    if header_row is None:
        raise ValueError("Не знайдено рядка із заголовками (очікується слово 'ТМЦ').")
    
    # =========================
    # Зчитування даних із встановленими заголовками
    # =========================
    # Перезчитуємо дані з аркуша, використовуючи знайдений рядок як заголовок.
    df = pd.read_excel(file_path, sheet_name=sheet_name, header=header_row)
    
    # =========================
    # Фільтрація даних
    # =========================
    # Видаляємо рядки, де значення в колонці "ТМЦ" є порожніми.
    df = df.dropna(subset=['ТМЦ'])
    
    # =========================
    # Перейменування колонок
    # =========================
    # Якщо у DataFrame є стовпець "Количество продажи", перейменовуємо його в "Количество".
    if 'Количество продажи' in df.columns:
        df.rename(columns={'Количество продажи': 'Количество'}, inplace=True)
    # Якщо є стовпець "Количество заказа", перейменовуємо його в "Количество".
    if 'Количество заказа' in df.columns:
        df.rename(columns={'Количество заказа': 'Количество'}, inplace=True)
    # Якщо є стовпець "Дата отгрузки", перейменовуємо його в "Дата".
    if 'Дата отгрузки' in df.columns:
        df.rename(columns={'Дата отгрузки': 'Дата'}, inplace=True)
    
    # =========================
    # Обробка дати
    # =========================
    # Конвертуємо значення в колонці "Дата" у формат datetime згідно з форматом "день.місяць.рік".
    df['Дата'] = pd.to_datetime(df['Дата'], format='%d.%m.%Y', dayfirst=True, errors='coerce')
    
    # =========================
    # Обробка ІНН клієнта
    # =========================
    # Якщо присутній стовпець "ИНН клиента", очищуємо його:
    # - Перетворюємо значення у рядки, видаляємо коми та крапки.
    # - Розбиваємо за символами "-" або "–" і залишаємо перший сегмент.
    # - Перетворюємо значення у числовий тип, заповнюємо пропуски нулем і задаємо тип 'Int64'.
    if 'ИНН клиента' in df.columns:
        df['ИНН клиента'] = (
            df['ИНН клиента'].astype(str)
            .str.replace(',', '', regex=False)
            .str.replace('.', '', regex=False)
            .str.split(r'[-–]', n=1).str[0]
            .apply(pd.to_numeric, errors='coerce')
            .fillna(0)
            .astype('Int64')
        )
    
    # =========================
    # Обробка кількості
    # =========================
    # Якщо присутній стовпець "Количество", перетворюємо його значення у числовий тип та округлюємо.
    if 'Количество' in df.columns:
        df['Количество'] = pd.to_numeric(df['Количество'], errors='coerce')
        df['Количество'] = df['Количество'].round()
    # Фільтруємо рядки, де значення "Количество" є валідними (не NaN).
    df = df[df['Количество'].notna()]
    
    # =========================
    # Призначення цін
    # =========================
    # Отримуємо словник з цінами для заданої організації.
    prices = get_prices(organization)
    # За допомогою методу map, зіставляємо значення в колонці "ТМЦ" зі словником цін.
    # Якщо відповідна ціна не знайдена, встановлюємо значення за замовчуванням (1).
    df['Цена'] = df['ТМЦ'].map(prices).fillna(1)
    # Перетворюємо значення в колонці "Цена" у числовий тип.
    df['Цена'] = pd.to_numeric(df['Цена'], errors='coerce')
    
    # =========================
    # Розрахунок суми
    # =========================
    # Розраховуємо суму для кожного рядка в залежності від організації:
    # - Для "Stada" встановлюємо суму рівною 1.
    # - Для "Arterium", "Astra Zeneca", "Binnopharm Group" та "Egis" перевіряємо,
    #   чи присутній товар (значення в "ТМЦ") у словнику цін і обчислюємо суму як добуток "Количество" на "Цена",
    #   інакше встановлюємо суму рівною 1.
    # - Для інших організацій розраховуємо суму як добуток "Количество" на "Цена".
    if organization == 'Stada':
        df['Сумма'] = 1
    elif organization == 'Arterium':
        df['Сумма'] = df.apply(
            lambda row: row['Количество'] * row['Цена'] if row['ТМЦ'] in prices else 1,
            axis=1
        )
    elif organization == 'Astra Zeneca':
        df['Сумма'] = df.apply(
            lambda row: row['Количество'] * row['Цена'] if row['ТМЦ'] in prices else 1,
            axis=1
        )
    elif organization == 'Binnopharm Group':
        df['Сумма'] = df.apply(
            lambda row: row['Количество'] * row['Цена'] if row['ТМЦ'] in prices else 1,
            axis=1
        )
    elif organization == 'Egis':
        df['Сумма'] = df.apply(
            lambda row: row['Количество'] * row['Цена'] if row['ТМЦ'] in prices else 1,
            axis=1
        )
    else:
        df['Сумма'] = df['Количество'].astype(float) * df['Цена']
    
    # =========================
    # Встановлення виробника
    # =========================
    # Якщо стовпець "Производитель" відсутній, встановлюємо його значення за замовчуванням "Без организации".
    if 'Производитель' not in df.columns:
        df['Производитель'] = 'Без организации'
    
    # =========================
    # Додавання порядкового номера
    # =========================
    # Додаємо нову колонку "Номер" з послідовними номерами для кожного рядка.
    df['Номер'] = range(1, len(df) + 1)
    # Переставляємо колонки так, що "Номер" буде першою колонкою, а всі інші — після неї.
    columns = ['Номер'] + [col for col in df.columns if col != 'Номер']
    df = df[columns]
    
    # =========================
    # Робота з ІНН
    # =========================
    # Відкриваємо JSON файл "_INN.json" для отримання даних про ІНН.
    with open('_INN.json', 'r', encoding='utf-8') as f:
        inn_data = json.load(f)
    
    # Функція для отримання ІНН за назвою клієнта з JSON файлу.
    def get_inn_from_json(client_name):
        client_name = client_name.strip().replace('"', '').replace('`', '').replace('mas`uliyati cheklangan jamiyati', '').strip()
        return inn_data.get(client_name, 111111111)
    
    # =========================
    # Додавання або оновлення колонки "ИНН клиента"
    # =========================
    # Якщо стовпець "ИНН клиента" відсутній, перевіряємо наявність стовпця "Клиент"
    # і створюємо "ИНН клиента" на основі його значень за допомогою функції get_inn_from_json.
    if 'ИНН клиента' not in df.columns:
        if 'Клиент' not in df.columns:
            raise ValueError("Не знайдено колонок 'ИНН клиента' або 'Клиент'.")
        df['ИНН клиента'] = df['Клиент'].apply(get_inn_from_json)
    else:
        # Якщо стовпець існує, оновлюємо його: якщо значення рівне 0, використовуємо функцію get_inn_from_json.
        df['ИНН клиента'] = df.apply(
            lambda row: get_inn_from_json(row['Клиент']) if row['ИНН клиента'] == 0 else row['ИНН клиента'],
            axis=1
        )
    
    # =========================
    # Видалення підсумкових рядків
    # =========================
    # Видаляємо рядки, які містять слово "итого" (без урахування регістру) в будь-якому полі,
    # оскільки вони є підсумковими і не потрібні.
    df = df[~df.apply(lambda row: row.astype(str).str.lower().str.contains("итого").any(), axis=1)]
    
    # =========================
    # Оновлення даних про виробника
    # =========================
    # Викликаємо функцію set_manufacturer_for_organization для встановлення або оновлення даних про виробника.
    df = set_manufacturer_for_organization(df, organization)
    
    # =========================
    # Об'єднання даних
    # =========================
    # Обгортаємо отриманий DataFrame у список і об'єднуємо його за допомогою функції combine_dataframes.
    df_list = [df]  # При потребі можна об'єднати декілька DataFrame.
    combined_df = combine_dataframes(df_list)
    
    # Повертаємо остаточно оброблений DataFrame.
    return df
